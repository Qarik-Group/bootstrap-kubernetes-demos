#!/bin/bash

set -eu

cd "$( cd "$( dirname "${BASH_SOURCE[0]}" )/.." && pwd )"

_system_domain() {
  [[ -f state/configuration/kubecf-system-domain ]] || {
    if [[ -f state/configuration/ingress-domain ]]; then
      cp state/configuration/ingress-domain state/configuration/kubecf-system-domain
    else
    echo "${CF_SYSTEM_DOMAIN:-kubecf.dev}" > state/configuration/kubecf-system-domain
    fi
  }
  cat state/configuration/kubecf-system-domain
}

_namespace() {
  [[ -f state/configuration/kubecf-namespace ]] || {
    echo "${CF_NAMESPACE:-kubecf}" > state/configuration/kubecf-namespace
  }
  cat state/configuration/kubecf-namespace
}

_default_version() {
  grep "kubecf" .versions | cut -d= -f2
}

_values_file() {
  mkdir -p state/configuration/kubecf
  printf "state/configuration/kubecf/values.yaml"
}

discover_versions() {
  # Install latest from CI/S3 bucket by default
  # Usage: KUBECF_RELEASE_URL=path/to/kubecf/bazel-bin/deploy/helm/kubecf/kubecf-3.0.0.tgz
  : "${KUBECF_RELEASE_URL:=}"
}

failfast() {
  # aws cli not current required for all code paths
  # [[ "$(command -v aws)X" != "X" ]] || { echo "ERROR: missing 'aws' CLI so we can look up latest kubecf release from S3 bucket" >> $1; }
  printf ""
}

up() {
  discover_versions
  failfast
  echo "Install Cloud Foundry/Eirini (kubecf) for $(_system_domain)"
  [[ "${KUBECF_RELEASE_URL:-X}" == "X" ]] && {
    KUBECF_RELEASE_URL="https://github.com/SUSE/kubecf/releases/download/v$(_default_version)/kubecf-$(_default_version).tgz"
  }
  [[ -f $(_values_file) ]] || {
    echo "Creating initial $(_values_file)"
    mkdir -p state/configuration/kubecf
    cat > state/configuration/kubecf/values.yaml <<YAML
system_domain: $(_system_domain)

features:
  eirini:
    enabled: true
  ingress:
    enabled: true

services:
  router:
    externalIPs: []
  ssh-proxy:
    externalIPs: []
  tcp-router:
    externalIPs: []

kube:
  pod_cluster_ip_range: 0.0.0.0/0
  service_cluster_ip_range: 0.0.0.0/0
YAML
  }

  echo "--> Using ${KUBECF_RELEASE_URL}"
  ns=$(_namespace)
  values_file=$(_values_file)
  (
    set -x
    helm upgrade --install --namespace "$ns" \
      kubecf \
      "$KUBECF_RELEASE_URL" \
      --values $values_file
  )

  echo "Upgrade buildpacks"
  helm repo add starkandwayne https://helm.starkandwayne.com
  helm repo update

  (
    set -x
    helm upgrade --install --namespace  "$ns" \
      update-all-cf-buildpacks \
      starkandwayne/update-all-cf-buildpacks
  )
}

kwt_routing() {
  [[ "$(command -v kwt)X" != "X" ]] || { echo "ERROR: install 'kwt'"; exit 1; }

  api_ip=$(kubectl get svc -n "$(_namespace)" kubecf-router-0 --template '{{.spec.clusterIP}}')

  echo "Mapping *.$(_system_domain) to internal IP ${api_ip}..."
  echo
  echo "Login with:"
  echo "cf login -a https://api.$(_system_domain) --skip-ssl-validation -u admin \\"
  echo '   -p "$(kubectl get secret -n kubecf kubecf.var-cf-admin-password -o json | jq -r .data.password | base64 --decode)"'
  echo
  system_domain=$(_system_domain)
  namespace=$(_namespace)
  set -x
  sudo -E kwt net start --dns-map "${system_domain}=${api_ip}" --namespace "$namespace"
}

case "${1:-usage}" in
  failfast)
    shift
    failfast "$@"
    ;;

  up)
    shift
    up
    ;;

  kwt)
    shift
    kwt_routing
    ;;

  *)
    ;;
esac
